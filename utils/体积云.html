<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ThreeJS</title>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      li {
        list-style: none;
      }
      .container {
        width: 100vw;
        height: 100vh;
        background-color: skyblue;
      }
    </style>
  </head>
  <body>
    <!-- https://www.shadertoy.com/view/WlfXzX -->
    <div id="container" class="container"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "../../libs/three.module.js",
          "three/examples/": "../../libs/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three'

      import Three from '../main.js'
      import gsap from '../../libs/gsap-core.js'

      const three = new Three({
          cameraPosition: new THREE.Vector3(0, 0, 10),
          outputEncoding: THREE.LinearEncoding
        }),
        { scene } = three.getProperty()

      three.execute(() => {
        const texture = three.loadTexture('/texture/uv-grid.jpg')

        const geometry = new THREE.PlaneGeometry(5, 5)

        const material = new THREE.ShaderMaterial({
          uniforms: {
            iTime: {
              value: -5
            },
            iResolution: {
              value: new THREE.Vector2(1184 * 1.5, 898 * 1.5)
            },
            iMouse: {
              value: new THREE.Vector2(0, 100)
            },

            iChannel0: {
              value: three.loadTexture('/texture/下载.png')
            }
          },
          vertexShader: /* glsl */ `
                        precision highp float;

                        varying vec2 vUv;
                
                        void main() {
                            vUv = uv;

                            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
                        }
                    `,
          fragmentShader: /* glsl */ `
                        precision highp float;

                        varying vec2 vUv;

                        uniform float iTime;
                        uniform vec2 iResolution;
                        uniform vec4 iMouse;

                         uniform sampler2D iChannel0; 

                         vec4 permute(vec4 x) {
                            return mod(((x * 34.0) + 1.0) * x, 289.0);
                        }

                        vec2 fade(vec2 t) {
                            return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
                        }

                        // 柏林噪声
                        float perlinNoise(vec2 P) {
                            vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
                            vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
                            Pi = mod(Pi, 289.0);

                            vec4 ix = Pi.xzxz;
                            vec4 iy = Pi.yyww;
                            vec4 fx = Pf.xzxz;
                            vec4 fy = Pf.yyww;

                            vec4 i = permute(permute(ix) + iy);
                            vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;
                            vec4 gy = abs(gx) - 0.5;
                            vec4 tx = floor(gx + 0.5);
                            gx = gx - tx;

                            vec2 g00 = vec2(gx.x, gy.x);
                            vec2 g10 = vec2(gx.y, gy.y);
                            vec2 g01 = vec2(gx.z, gy.z);
                            vec2 g11 = vec2(gx.w, gy.w);

                            vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
                            g00 *= norm.x;
                            g01 *= norm.y;
                            g10 *= norm.z;
                            g11 *= norm.w;

                            float n00 = dot(g00, vec2(fx.x, fy.x));
                            float n10 = dot(g10, vec2(fx.y, fy.y));
                            float n01 = dot(g01, vec2(fx.z, fy.z));
                            float n11 = dot(g11, vec2(fx.w, fy.w));

                            vec2 fade_xy = fade(Pf.xy);
                            vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                            float n_xy = mix(n_x.x, n_x.y, fade_xy.y);

                            return 2.3 * n_xy;
                        }

                         mat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }

                        
                        float noise(vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
	f = f*f*(3.0-2.0*f);
	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
    vec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;
	return -1.0+2.0*mix( rg.x, rg.y, f.z );
}

float smoke(vec3 p) {
    //return clamp(1. - length(p), 0., 1.);
    vec3 q = 1.2 * p;
    float f = 0., a = .5;
    for(int i = 0; i < 5; ++i, a *= .4, q *= 2.1) { // fbm
        q += iTime * vec3(.17, -.5, 0);
        f += a * perlinNoise(vec2(q.xy) * 1.0);
    }
    float noiseShape = .5 + .7 * max(p.y, 0.) - .15 * length(p.xz);
    return clamp(1. +  noiseShape * f - length(p), 0., 1.);
}

vec3 shading(vec3 ro, vec3 rd) {
    vec3 ld = normalize(vec3(.5, 1, -.7));
    
    const float nbStep = 10., diam = 3., rayLength = diam / nbStep;
    float start = length(ro) - diam / 2., end = start + diam;
    float sumDen = 0., sumDif = 0.;
    
    for(float d = end; d > start; d -= rayLength) { // raymarching
        vec3 p = ro + d * rd;
    	if(dot(p,p) > diam * diam) break;
        float den = smoke(p);
        sumDen += den;
        if(den > .02) sumDif += max(0., den - smoke(p + ld * .17));
    }

    const vec3 lightCol = vec3(.95, .75, .3);
    float light = 10. * pow(max(0., dot(rd, ld)), 10.);
    vec3 col = .01 * light * lightCol;
    col +=  .4 * sumDen * rayLength * vec3(.8, .9, 1.); // ambient
    col += 1.3 * sumDif * rayLength * lightCol;         // diffuse
	return col;
}

void main() {
    vec2 uv = vUv;
    vec3 rd = normalize(vec3(uv - 0.5, -2.07));

    // vec2 ang = (iMouse.xy * 1.5) / iResolution.xy;
    // float yaw = 7. * ang.x;
    // float pitch = + (ang.y);

    vec3 camPos = vec3(0.0, 0.3, 6.5);
    // camPos.yz *= rot(pitch); camPos.zx *= rot(yaw);
    // rd.yz     *= rot(pitch);     rd.zx *= rot(yaw);

	// gl_FragColor = vec4(pow(shading(camPos, rd), vec3(1. / 2.2)), 1.);

    gl_FragColor = vec4(shading(camPos, rd), 1.0);
}               
                    `
        })

        scene.add(new THREE.Mesh(geometry, material))

        // gsap.to(material.uniforms.iTime, {
        //     value: 1,
        //     duration: 1,
        // });

        three.addRenderCallback(timeData => {
          material.uniforms.iTime.value += timeData.deltaTime

          // console.log(material.uniforms.iTime.value);
        })
      })
    </script>
  </body>
</html>
